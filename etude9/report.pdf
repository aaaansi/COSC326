Junior Developer Code Review Report
Hi JD, I've looked at your code and I've made some points for you to reflect upon. I have also decided to write
my own code which should do the same task as what your programs goal is so you can compare between the two.

Starting small from Makefile
    - Your makefile command does not contain warning flags enabled such as -W and -pedantic can help identify problems when compiling
    - Your build target isnt very descriptive, give your executable a semantic name.

File "Main.c" problems
    - Use Meaningful Variable Names: Avoid using single-letter variable names like "i," "j," or "s" as they make the code harder to read and understand.
      Instead, use descriptive names that indicate the purpose of the variables, such as "firstNameIndex" or "currentClient."
    - Encapsulate Functionality: Consider organizing related code into functions or modules to improve code readability and maintainability. 
      Separate functions can handle tasks such as reading data from a file, sorting, searching, and displaying results.
      This approach promotes code reuse and makes it easier to modify or extend the code in the future.
    - Implement Input Validation: Validate user input to prevent errors and unexpected behavior. For example, check if the file was successfully opened, ensure the user enters a valid command, and validate the input values to match the expected data types.
      Proper input validation helps prevent crashes and enhances the user experience.
    - Avoid Magic Numbers: Replace magic numbers with named constants or variables that convey their meaning. For instance, instead of using the number "10" in the command input loop, define a constant like "const int EXIT_COMMAND = 0;" and use it in the code.
      This improves code readability and makes it easier to modify values in the future.
    - Use Comparison Functions: Instead of writing separate sorting functions for each field, consider using comparison functions or function pointers to make the sorting process more generic.
      This approach allows the code to handle sorting based on different fields by using a single sorting function.
    - Implement Memory Deallocation: Properly deallocate dynamically allocated memory using the free() function to prevent memory leaks.
      Currently, the code does not explicitly free the memory allocated for each client's fields, which can lead to memory leaks and inefficient memory usage.
      Remember to free the memory after it is no longer needed.
    - Comment and Document the Code: Add comments to explain the purpose, functionality, and logic of the code. 
      Documenting the code helps other developers, including your future self, understand the codebase and make modifications or improvements more efficiently.
    - Test the Code Rigorously: Ensure you thoroughly test the code with different scenarios, including edge cases and invalid inputs. Identify and fix any bugs or unexpected behavior.
      Testing helps improve the code's reliability, stability, and functionality.
    - Read Code Style Guidelines: Familiarize yourself with established code style guidelines, such as the ones provided by your organization or popular style guides like Google C++ Style Guide or GNU Coding Standards.
      Following consistent code style conventions improves code readability and collaboration with other developers.
    - Seek Feedback and Learn from Others: Share your code with more experienced developers or participate in code reviews. Gather feedback and actively learn from their suggestions and advice. This helps you improve your coding skills, gain new insights, and enhance the quality of your code.

And with some quick scanning over your code you can also see that you should have:
    - Removed unnecessary use of <math.h> header. removing it means you can also get rid of -lm flag in makefile
    - Removed duplicate #include <stdio.h> statement
    - Avoid using variable names without meaning  for example Struct "S" can be called Struct "Customer" to easily understand its contents better.
    - Changed struct name "S" to ease readability from S to something more meaningful like "Customer"
    - Changed struct to typedef so I can give it a pointer that I can simply declare variables with for example "Customer cust;" instead of "struct Customer *cust;" 
    - Misspelling for words like "emialAddress" to "emailAddress".
    - Changed data type of phone from int to char to avoid overflow and because int removes leading zeros and can only take up to 10 digits
    - Defined the lengths of struct fields. You can do this for example like "#define MAX_FIELD_LEN 256" and then you can use MAX_FIELD_LEN to set the length of the field.
    - Avoid using global variables i, j, and count should be local variables to avoid potential errors if you were to modify them.
    - Looking at the main() we can see that we are using the methods of sorting the fields by order before we try to search for what the users looking for
      These methods are useless as we can jump straight to searching without the need to sort.
    - Renamed the variable ss to customerArray for better clarity and descriptive naming. and Updated function signatures and usages of Customer and customerArray accordingly.
    - Added error handling for file opening and memory allocation failures.
    - Added a function freeCustomerData to handle freeing the dynamically allocated memory for the Customer structures and their members.

In summary, the code written lacks modularity, suffers from poor variable naming, lacks error handling, and has incorrect string comparisons. 
By refactoring the code to improve modularity, using meaningful variable names, implementing error handling, correcting string comparisons,
applying efficient sorting algorithms, managing memory dynamically, and adding proper function documentation. You should also aim to provide user feed back as the program goes on, for example asking the user what field would they like to search by and handling that properly. Doing these will make sure the code become more readable, maintainable, and robust.
